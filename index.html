<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADF sur ND</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            touch-action: manipulation;
            overflow-x: hidden;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
            text-align: center;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100vw;
            max-width: 100vw;
            box-sizing: border-box;
            padding: 0;
        }
        .instructions {
            background-color: white;
            padding: 12px 0;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 100vw;
            max-width: 100vw;
            box-sizing: border-box;
            text-align: center;
            margin: 0;
        }
        .instructions p {
            margin: 8px 0;
            font-size: clamp(0.9rem, 2vw, 1rem);
            line-height: 1.4;
        }
        .consigne {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            text-align: left;
            width: 95%;
            max-width: 900px;
        }
        .consigne h3 {
            color: #856404;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .consigne p {
            margin: 5px 0;
            font-size: 0.95em;
            line-height: 1.4;
        }
        .astuce {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-style: italic;
            font-size: 0.9em;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            width: 100vw;
            max-width: 100vw;
            box-sizing: border-box;
            margin: 0;
        }
        button {
            padding: 12px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            flex: 1;
            min-width: 140px;
            max-width: 200px;
            touch-action: manipulation;
        }
        button:hover, button:active {
            background-color: #45a049;
        }
        .jeu-reponse-row {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            width: 100vw;
            max-width: 100vw;
            box-sizing: border-box;
            gap: 20px;
            margin: 0 auto;
        }
        #canvasContainer {
            flex: 3 1 0%;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 200px;
            max-width: 1000px;
            position: relative;
            height: 500px;
        }
        #reponsesBox {
            flex: 1 1 0%;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            padding: 18px 12px;
            min-width: 150px;
            max-width: 220px;
            font-size: 1.05em;
            color: #d63c3c;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-top: 30px;
        }
        @media (max-width: 900px) {
            body {
                overflow-y: auto; /* Permettre le d√©filement sur mobile */
                height: auto;
            }
            .jeu-reponse-row {
                flex-direction: column;
                align-items: center;
                gap: 8px;
            }
            #reponsesBox {
                margin-top: 8px;
                align-items: center;
                min-width: unset;
                max-width: 95vw;
                width: 95vw;
                font-size: 1em;
                text-align: center;
            }
            .consigne {
                padding: 12px;
                margin: 8px 10px;
            }
            #canvasContainer {
                height: 400px;
                max-width: 95vw;
            }
            .controls {
                flex-direction: column;
                align-items: center;
            }
            button {
                max-width: 95vw;
                width: 95vw;
            }
        }
        /* Aide modale */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            background: rgba(30,30,30,0.5);
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex;
        }
        .modal > div {
            background: #fff;
            padding: 24px 20px;
            border-radius: 12px;
            max-width: 350px;
            margin: 50px auto;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            text-align: left;
            position: relative;
        }
        .closeBtn {
            position: absolute; 
            top: 5px; 
            right: 7px; 
            background: transparent; 
            border: none; 
            font-size: 1.6em; 
            cursor: pointer;
        }
        .helpBtn {
            background: #eee; 
            color: #333;
            border: 1px solid #ccc; 
            border-radius: 5px; 
            font-size: 1rem; 
            padding: 4px 12px; 
            cursor: pointer;
            margin-bottom: 8px;
        }
        .help-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            margin: 5px;
            touch-action: manipulation;
            cursor: pointer;
        }
        .desktop-controls {
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .reponse-btn {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            margin: 5px;
            font-size: 14px;
            cursor: pointer;
            width: 180px;
            text-align: center;
            touch-action: auto;
            -webkit-tap-highlight-color: transparent;
        }
        .contact-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #666;
            z-index: 100;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .contact-info a {
            color: #0066cc;
            text-decoration: none;
        }
        .contact-info a:hover {
            text-decoration: underline;
        }
        .hidden {
            display: none !important;
        }
        /* Styles sp√©cifiques pour mobile */
        @media (max-width: 768px) {
            .container {
                gap: 10px;
            }
            .consigne {
                margin: 5px;
                width: 98%;
            }
            .help-buttons {
                flex-direction: column;
                width: 95%;
            }
            .helpBtn {
                width: 100%;
                margin-bottom: 5px;
            }
            #canvasContainer {
                height: 350px; /* R√©duit un peu pour mobile */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Navigation ADF sur ND</h1>
        
        <div class="consigne">
            <h3>üìã Consigne :</h3>
            <p><strong>D√©termine la position de l'avion, son cap, le gisement ainsi que les rel√®vements QDR et QDM √† partir de l'instrument.</strong></p>
            <p>D√©placez l'avion dans la zone bleue et modifiez son cap pour observer les changements dans les mesures.</p>
            
            <div class="astuce">
                <strong>Astuce :</strong><br>
                ‚Ä¢ Sur ordinateur : clic gauche pour d√©placer l'avion, clic droit pour modifier le cap<br>
                ‚Ä¢ Sur mobile : utilisez les boutons + et - pour modifier le cap, et touchez la zone bleue pour d√©placer l'avion<br>
                ‚Ä¢ La fl√®che double indique le QDM vers la balise de droite (NDB 2)<br>
                ‚Ä¢ La fl√®che simple indique le QDM vers la balise de gauche (NDB 1)
            </div>
        </div>

        <div class="controls">
            <button id="randomBothBtn">Position/Cap Al√©atoire (3)</button>
            <button id="toggleReponseBtn">Afficher/Masquer R√©ponse</button>
        </div>
        
        <div class="jeu-reponse-row">
            <div id="canvasContainer">
                <!-- Le canvas sera ins√©r√© ici via JS -->
                <div id="mobileControls" class="mobile-controls hidden">
                    <button class="control-btn" id="capPlus">+</button>
                    <button class="control-btn" id="capMoins">-</button>
                </div>

                <div id="desktopControls" class="desktop-controls hidden">
                    <!-- Contr√¥les desktop - vide pour l'instant -->
                </div>
            </div>
            <div id="reponsesBox">
                <!-- Les r√©ponses s'affichent ici via JS -->
            </div>
        </div>
        
        <div class="help-buttons">
            <button id="showTermsBtn" class="helpBtn" type="button">‚ùì Explication des termes (GT, QDM, QDR, Cap)</button>
            <button id="showButtonsBtn" class="helpBtn" type="button">üîÑ Explication des boutons</button>
        </div>
        
        <!-- Modal pour les termes -->
        <div id="termsModal" class="modal">
            <div>
                <button class="closeBtn" aria-label="Fermer la fen√™tre d'aide">&times;</button>
                <h2 style="font-size:1.1em;margin-top:0;">Que signifient GT, QDM, QDR et Cap&nbsp;?</h2>
                <ul style="padding-left:16px;font-size:1em;line-height:1.5;">
                    <li><strong>GT&nbsp;:</strong> <em>Gisement transmis</em> par l'ADF, angle entre le nez de l'avion et la direction de la balise.</li>
                    <li><strong>QDM&nbsp;:</strong> Cap magn√©tique √† suivre pour aller vers la balise depuis la position de l'avion.</li>
                    <li><strong>QDR&nbsp;:</strong> Rel√®vement magn√©tique de la balise, cap √† suivre pour s'√©loigner de la balise.</li>
                    <li><strong>Cap&nbsp;:</strong> Direction (en degr√©s) du nez de l'avion par rapport au nord magn√©tique.</li>
                </ul>
            </div>
        </div>
        
        <!-- Modal pour les boutons -->
        <div id="buttonsModal" class="modal">
            <div>
                <button class="closeBtn" aria-label="Fermer la fen√™tre d'aide">&times;</button>
                <h2 style="font-size:1.1em;margin-top:0;">√Ä quoi servent les boutons&nbsp;?</h2>
                <ul style="padding-left:16px;font-size:1em;line-height:1.5;">
                    <li><strong>Position/Cap Al√©atoire (3)&nbsp;:</strong> Change √† la fois la position et le cap de l'avion.</li>
                    <li>Sur ordinateur cela fonctionne avec la touche 3</li>
                    <li><strong>Afficher/Masquer R√©ponse&nbsp;:</strong> Montre ou cache les valeurs r√©elles (GT, QDM, QDR, Cap).</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="instructions">
        <p>Lyc√©e professionnel Roger Claustres - renaud.boulier@ac-clermont.fr</p>
    </div>
    
    <script>
        let imgNDcadre, imgNDmaquette, imgNDrose, imgtraicap;
        let flecheNDDouble, flecheNDSimple, imgNDB, imgPlane;
        let rose = 0;
        let QDR1, QDR3, QDM, QDM1, GT, GT1;
        let mx1, mx2, my1, my2, mmx, mmy;
        let rot;
        let reponse = false;
        let baliseLH, baliseRH, avion, avion1;
        let isMobile = false;
        let imagesLoaded = false;
        
        // Variables pour le contr√¥le continu du cap
        let rightMousePressed = false;
        let leftMousePressed = false;
        let lastUpdateTime = 0;
        const CAP_CHANGE_INTERVAL = 16;

        // Variables pour le contr√¥le mobile
        let capPlusPressed = false;
        let capMoinsPressed = false;

        // Variables pour le zoom et d√©placement
        let zoomScale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastTouchX, lastTouchY;
        let lastTouchDistance = 0;

        // Variable pour contr√¥ler le d√©placement de l'avion
        let aircraftMoving = false;

        // Variables pour la zone de d√©limitation des balises
        let baliseZone = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            padding: 100
        };

        function preload() {
            // Images avec gestion d'erreur
            try {
                imgNDcadre = loadImage('NDcadre.png');
                imgNDmaquette = loadImage('NDmaquette.png');
                imgNDrose = loadImage('NDrose.png');
                flecheNDDouble = loadImage('NDDouble.png');
                flecheNDSimple = loadImage('NDSimple.png');
                imgNDB = loadImage('NDB.png');
                imgPlane = loadImage('plane.png');
                imgtraicap = loadImage('traicap.png');
                imagesLoaded = true;
            } catch (e) {
                console.log("Certaines images n'ont pas pu √™tre charg√©es, utilisation des graphiques de secours");
                imagesLoaded = false;
            }
        }

        function setup() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      ('ontouchstart' in window) || 
                      (navigator.maxTouchPoints > 0);
            
            // Canvas adaptatif selon le device
            let canvasWidth, canvasHeight;
            if (isMobile) {
                canvasWidth = windowWidth * 0.95;
                canvasHeight = windowHeight * 0.5; // R√©duit √† 50% pour permettre le d√©filement
            } else {
                canvasWidth = 1000;
                canvasHeight = 500;
            }
            
            let canvas = createCanvas(canvasWidth, canvasHeight);
            canvas.parent('canvasContainer');
            canvas.style('display', 'block');
            canvas.style('cursor', 'default');
            
            // Emp√™cher les √©v√©nements de touch sur le canvas d'interf√©rer avec les boutons
            canvas.elt.addEventListener('touchstart', function(e) {
                if (e.target === this) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            canvas.elt.addEventListener('touchmove', function(e) {
                if (e.target === this) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            baliseLH = createVector(0, -10);
            baliseRH = createVector(0, -10);
            imageMode(CENTER);
            rectMode(CENTER);
            textAlign(CENTER, CENTER);
            
            setupButtonEvents();
            setupControls();
        }

        function setupControls() {
            // S'assurer que les √©l√©ments existent avant d'ajouter des √©couteurs
            const mobileControls = document.getElementById('mobileControls');
            const desktopControls = document.getElementById('desktopControls');
            const capPlusBtn = document.getElementById('capPlus');
            const capMoinsBtn = document.getElementById('capMoins');

            if (isMobile) {
                // Afficher les contr√¥les mobiles
                if (mobileControls) mobileControls.classList.remove('hidden');
                if (desktopControls) desktopControls.classList.add('hidden');
                
                // Boutons + et - pour mobile
                if (capPlusBtn) {
                    capPlusBtn.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        capPlusPressed = true;
                    }, {passive: false});
                    
                    capPlusBtn.addEventListener('touchend', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        capPlusPressed = false;
                    }, {passive: false});
                }
                
                if (capMoinsBtn) {
                    capMoinsBtn.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        capMoinsPressed = true;
                    }, {passive: false});
                    
                    capMoinsBtn.addEventListener('touchend', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        capMoinsPressed = false;
                    }, {passive: false});
                }
                
            } else {
                // Afficher les contr√¥les desktop
                if (mobileControls) mobileControls.classList.add('hidden');
                if (desktopControls) desktopControls.classList.remove('hidden');
            }
        }

        function setupButtonEvents() {
            // Boutons de contr√¥le principaux - seulement le bouton "Position/Cap Al√©atoire"
            const randomBothBtn = document.getElementById('randomBothBtn');
            const toggleReponseBtn = document.getElementById('toggleReponseBtn');
            
            if (randomBothBtn) {
                randomBothBtn.addEventListener('click', randomBoth);
                randomBothBtn.addEventListener('touchend', function(e) {e.preventDefault(); randomBoth();});
            }
            
            if (toggleReponseBtn) {
                toggleReponseBtn.addEventListener('click', toggleReponse);
                toggleReponseBtn.addEventListener('touchend', function(e) {e.preventDefault(); toggleReponse();});
            }
            
            // Boutons d'aide
            const showTermsBtn = document.getElementById('showTermsBtn');
            const showButtonsBtn = document.getElementById('showButtonsBtn');
            
            if (showTermsBtn) {
                showTermsBtn.addEventListener('click', function() {
                    document.getElementById('termsModal').classList.add('active');
                });
            }
            
            if (showButtonsBtn) {
                showButtonsBtn.addEventListener('click', function() {
                    document.getElementById('buttonsModal').classList.add('active');
                });
            }
            
            // Fermeture des modales
            document.querySelectorAll('.closeBtn').forEach(btn => {
                btn.addEventListener('click', function() {
                    this.closest('.modal').classList.remove('active');
                });
            });
            
            document.querySelectorAll('.modal').forEach(modal => {
                modal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        this.classList.remove('active');
                    }
                });
            });
        }

        function draw() {
            background(255);
            
            updateCapContinuous();

            if (!isMobile && leftMousePressed) {
                updateAircraftPosition();
            }

            push();
            translate(offsetX, offsetY);
            scale(zoomScale);

            let NDX, NDY, NDBX1, NDBY1, NDBX2, NDBY2;
            
            // Positionnement adaptatif selon le device
            if (isMobile) {
                // Layout vertical pour mobile
                NDX = width * 0.3;
                NDY = height * 0.3;
                NDBX1 = width * 0.7;
                NDBY1 = height * 0.25;
                NDBX2 = width * 0.7;
                NDBY2 = height * 0.5;
            } else {
                // Layout horizontal pour desktop
                NDX = 200;
                NDY = 183;
                NDBX1 = 600;
                NDBY1 = 183;
                NDBX2 = 850;
                NDBY2 = 383;
            }

            calculateBaliseZone(NDBX1, NDBY1, NDBX2, NDBY2);
            drawBaliseZone();

            if (mmx === undefined || mmy === undefined) {
                let centerX = baliseZone.x + baliseZone.width / 2;
                let centerY = baliseZone.y + baliseZone.height / 2;
                mmx = centerX * zoomScale + offsetX;
                mmy = centerY * zoomScale + offsetY;
            }

            // Tailles adaptatives
            let cadreSize, roseSize, traicapSize;
            if (isMobile) {
                cadreSize = min(width, height) * 0.4;
                roseSize = min(width, height) * 0.35;
                traicapSize = min(width, height) * 0.4;
            } else {
                cadreSize = 368;
                roseSize = 368;
                traicapSize = 368;
            }

            drawMainElements(NDX, NDY, cadreSize, roseSize, traicapSize, NDBX1, NDBY1, NDBX2, NDBY2);

            calculateNavigation(NDX, NDY, NDBX1, NDBY1, NDBX2, NDBY2);

            drawAircraft(NDX);

            // Dessiner les num√©ros sur les balises
            drawBaliseNumbers(NDBX1, NDBY1, NDBX2, NDBY2);

            pop(); // Fin de la transformation de zoom/d√©placement
            
            updateAnswers();
        }

        function drawBaliseNumbers(NDBX1, NDBY1, NDBX2, NDBY2) {
            // Num√©ro 1 sur la balise de gauche
            fill(255);
            textSize(isMobile ? 14 : 16);
            textAlign(CENTER, CENTER);
            text("1", NDBX1, NDBY1);
            
            // Num√©ro 2 sur la balise de droite
            text("2", NDBX2, NDBY2);
            textAlign(LEFT, CENTER);
        }

        function calculateBaliseZone(NDBX1, NDBY1, NDBX2, NDBY2) {
            const minX = min(NDBX1, NDBX2) - baliseZone.padding;
            const maxX = max(NDBX1, NDBX2) + baliseZone.padding;
            const minY = min(NDBY1, NDBY2) - baliseZone.padding;
            const maxY = max(NDBY1, NDBY2) + baliseZone.padding;
            
            baliseZone.x = minX;
            baliseZone.y = minY;
            baliseZone.width = maxX - minX;
            baliseZone.height = maxY - minY;
        }

        function drawBaliseZone() {
            stroke(0, 100, 255, 150);
            strokeWeight(3);
            noFill();
            rect(baliseZone.x + baliseZone.width/2, baliseZone.y + baliseZone.height/2, 
                 baliseZone.width, baliseZone.height);
            noStroke();
            
            fill(0, 100, 255);
            textSize(isMobile ? 10 : 12);
            textAlign(CENTER);
            text("Zone de d√©placement de l'avion", 
                 baliseZone.x + baliseZone.width/2, 
                 baliseZone.y - 15);
            textAlign(LEFT);
        }

        function isInBaliseZone(x, y) {
            return x >= baliseZone.x && 
                   x <= baliseZone.x + baliseZone.width && 
                   y >= baliseZone.y && 
                   y <= baliseZone.y + baliseZone.height;
        }

        function updateCapContinuous() {
            let currentTime = millis();
            if (currentTime - lastUpdateTime > CAP_CHANGE_INTERVAL) {
                if (!isMobile && rightMousePressed) {
                    rose = (rose + 1) % 360;
                }
                if (isMobile) {
                    if (capPlusPressed) rose = (rose + 2) % 360;
                    if (capMoinsPressed) rose = (rose - 2 + 360) % 360;
                }
                lastUpdateTime = currentTime;
            }
        }

        function updateAircraftPosition() {
            if (!isMobile && leftMousePressed) {
                let targetX = mouseX;
                let targetY = mouseY;
                
                let adjustedTargetX = (targetX - offsetX) / zoomScale;
                let adjustedTargetY = (targetY - offsetY) / zoomScale;
                
                if (isInBaliseZone(adjustedTargetX, adjustedTargetY)) {
                    mmx = targetX;
                    mmy = targetY;
                }
            }
        }

        function drawMainElements(NDX, NDY, cadreSize, roseSize, traicapSize, NDBX1, NDBY1, NDBX2, NDBY2) {
            if (imagesLoaded) {
                try {
                    image(imgNDcadre, NDX, NDY, cadreSize, cadreSize);
                    image(imgNDmaquette, NDX, NDY, cadreSize/10, cadreSize/10);

                    push();
                    translate(NDX, NDY);
                    rotate(radians(-rose));
                    image(imgNDrose, 0, 0, roseSize, roseSize); 
                    pop();
                   
                    // Dessiner l'image traicap.png fixe (ne bouge pas avec le cap)
                    image(imgtraicap, NDX, NDY, cadreSize, cadreSize); 
                    
                    push();
                    translate(NDX, NDY);
                    rotate(radians(QDM));  
                    image(flecheNDDouble, 0, 0, roseSize, roseSize);
                    pop();

                    push();
                    translate(NDX, NDY);
                    rotate(radians(QDM1));  
                    image(flecheNDSimple, 0, 0, roseSize, roseSize);
                    pop();

                    image(imgNDB, NDBX1, NDBY1);
                    image(imgNDB, NDBX2, NDBY2);
                    
                } catch (e) {
                    drawFallbackGraphics(NDX, NDY, cadreSize, roseSize, NDBX1, NDBY1, NDBX2, NDBY2);
                }
            } else {
                drawFallbackGraphics(NDX, NDY, cadreSize, roseSize, NDBX1, NDBY1, NDBX2, NDBY2);
            }
        }

        function drawFallbackGraphics(NDX, NDY, cadreSize, roseSize, NDBX1, NDBY1, NDBX2, NDBY2) {
            stroke(0);
            strokeWeight(2);
            noFill();
            rect(NDX, NDY, cadreSize, cadreSize);
            
            stroke(100);
            strokeWeight(1);
            noFill();
            circle(NDX, NDY, roseSize);
            
            fill(100);
            noStroke();
            rect(NDX-15, NDY, 30, 10);
            
            fill(255, 0, 0);
            circle(NDBX1, NDBY1, 20);
            circle(NDBX2, NDBY2, 20);
            
            stroke(255, 0, 0);
            strokeWeight(3);
            push();
            translate(NDX, NDY);
            rotate(radians(QDM));
            line(0, 0, 0, -100);
            pop();
            
            stroke(0, 0, 255);
            push();
            translate(NDX, NDY);
            rotate(radians(QDM1));
            line(0, 0, 0, -120);
            pop();
        }

        function calculateNavigation(NDX, NDY, NDBX1, NDBY1, NDBX2, NDBY2) {
            let adjustedMmx = (mmx - offsetX) / zoomScale;
            let adjustedMmy = (mmy - offsetY) / zoomScale;

            mx1 = adjustedMmx - NDBX1;
            my1 = adjustedMmy - NDBY1;
            avion = createVector(mx1, my1);
            
            let angle1 = atan2(my1, mx1);
            QDR1 = degrees(angle1);
            if (QDR1 < 0) QDR1 += 360;
            
            QDM1 = (QDR1 + 180) % 360;
            GT = (QDM1 - rose + 360) % 360;

            mx2 = adjustedMmx - NDBX2;
            my2 = adjustedMmy - NDBY2;
            avion1 = createVector(mx2, my2);
            
            let angle2 = atan2(my2, mx2);
            QDR3 = degrees(angle2);
            if (QDR3 < 0) QDR3 += 360;
            
            QDM = (QDR3 + 180) % 360;
            GT1 = (QDM - rose + 360) % 360;
        }

        function drawAircraft(NDX) {
            let adjustedMmx = (mmx - offsetX) / zoomScale;
            let adjustedMmy = (mmy - offsetY) / zoomScale;

            push();
            translate(adjustedMmx, adjustedMmy);
            rotate(radians(rose));
            if (imagesLoaded) {
                try {
                    image(imgPlane, 1, 5);
                } catch (e) {
                    drawFallbackAircraft();
                }
            } else {
                drawFallbackAircraft();
            }
            pop();
        }

        function drawFallbackAircraft() {
            fill(255, 0, 0);
            triangle(-15, -10, 15, -10, 0, -25);
            rect(-5, 0, 10, 15);
        }

        function updateAnswers() {
            const reponsesBox = document.getElementById('reponsesBox');
            if (reponsesBox) {
                let txt = "";
                if (reponse) {
                    txt += "QDR1 = " + Math.round(QDR1) + "¬∞<br>";
                    txt += "QDM1 = " + Math.round(QDM1) + "¬∞<br>";
                    txt += "GT1 = " + Math.round(GT) + "¬∞<br>";
                    txt += "CAP = " + Math.round(rose) + "¬∞<br>";
                    txt += "QDR2 = " + Math.round(QDR3) + "¬∞<br>";
                    txt += "QDM2 = " + Math.round(QDM) + "¬∞<br>";
                    txt += "GT2 = " + Math.round(GT1) + "¬∞";
                } else {
                    txt += "QDR1 = ?<br>QDM1 = ?<br>GT1 = ?<br>CAP = ?<br>QDR2 = ?<br>QDM2 = ?<br>GT2 = ?";
                }
                reponsesBox.innerHTML = txt;
            }
        }

        function mousePressed() {
            if (!isMobile) {
                if (mouseButton === RIGHT) {
                    rightMousePressed = true;
                    lastUpdateTime = millis();
                    return false;
                } else if (mouseButton === LEFT) {
                    let adjustedMouseX = (mouseX - offsetX) / zoomScale;
                    let adjustedMouseY = (mouseY - offsetY) / zoomScale;
                    
                    if (isInBaliseZone(adjustedMouseX, adjustedMouseY)) {
                        leftMousePressed = true;
                    }
                    return false;
                }
            }
            return false;
        }

        function mouseReleased() {
            if (!isMobile) {
                if (mouseButton === RIGHT) {
                    rightMousePressed = false;
                    return false;
                } else if (mouseButton === LEFT) {
                    leftMousePressed = false;
                    return false;
                }
            }
            return false;
        }

        function keyPressed() {
            // Seulement la touche 3 fonctionne maintenant
            if (key === '3') {
                randomBoth();
            }
        }

        function touchStarted(event) {
            if (isMobile) {
                // Ne traiter que les touches qui ne sont pas sur des boutons
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                
                const capPlusBtn = document.getElementById('capPlus');
                const capMoinsBtn = document.getElementById('capMoins');
                
                const isOnButton = 
                    (capPlusBtn && isTouchInElement(touchX, touchY, capPlusBtn)) ||
                    (capMoinsBtn && isTouchInElement(touchX, touchY, capMoinsBtn));
                
                // Si ce n'est pas sur un bouton, g√©rer le d√©placement
                if (!isOnButton) {
                    let adjustedTouchX = (touchX - offsetX) / zoomScale;
                    let adjustedTouchY = (touchY - offsetY) / zoomScale;
                    
                    if (isInBaliseZone(adjustedTouchX, adjustedTouchY)) {
                        aircraftMoving = true;
                        mmx = touchX;
                        mmy = touchY;
                        
                        if (touches.length === 1) {
                            isDragging = true;
                            lastTouchX = touchX;
                            lastTouchY = touchY;
                        } else if (touches.length === 2) {
                            lastTouchDistance = dist(
                                touches[0].x, touches[0].y,
                                touches[1].x, touches[1].y
                            );
                        }
                    }
                    return false;
                }
            }
            return false;
        }

        function touchMoved(event) {
            if (isMobile && aircraftMoving) {
                if (touches.length === 1 && isDragging) {
                    let targetX = touches[0].x;
                    let targetY = touches[0].y;
                    
                    let adjustedTargetX = (targetX - offsetX) / zoomScale;
                    let adjustedTargetY = (targetY - offsetY) / zoomScale;
                    
                    if (isInBaliseZone(adjustedTargetX, adjustedTargetY)) {
                        mmx = targetX;
                        mmy = targetY;
                    }
                } else if (touches.length === 2) {
                    let currentDistance = dist(
                        touches[0].x, touches[0].y,
                        touches[1].x, touches[1].y
                    );
                    
                    let zoomFactor = currentDistance / lastTouchDistance;
                    zoomScale *= zoomFactor;
                    zoomScale = constrain(zoomScale, 0.5, 3.0);
                    
                    lastTouchDistance = currentDistance;
                }
            }
            return false;
        }

        function touchEnded() {
            if (isMobile) {
                aircraftMoving = false;
                if (touches.length === 0) {
                    isDragging = false;
                }
            }
            return false;
        }

        function isTouchInElement(touchX, touchY, element) {
            if (!element) return false;
            const rect = element.getBoundingClientRect();
            return (
                touchX >= rect.left &&
                touchX <= rect.right &&
                touchY >= rect.top &&
                touchY <= rect.bottom
            );
        }

        function windowResized() {
            // Redimensionnement adaptatif
            if (isMobile) {
                resizeCanvas(windowWidth * 0.95, windowHeight * 0.5);
            } else {
                resizeCanvas(1000, 500);
            }
        }

        // Fonctions pour les boutons de contr√¥le
        function randomPosition() {
            let centerX = baliseZone.x + baliseZone.width / 2;
            let centerY = baliseZone.y + baliseZone.height / 2;
            
            let randomX = random(baliseZone.x, baliseZone.x + baliseZone.width);
            let randomY = random(baliseZone.y, baliseZone.y + baliseZone.height);
            
            mmx = randomX * zoomScale + offsetX;
            mmy = randomY * zoomScale + offsetY;
        }

        function randomCap() {
            rose = random(0, 359);
        }

        function randomBoth() {
            randomPosition();
            randomCap();
        }

        function toggleReponse() {
            reponse = !reponse;
            updateAnswers();
        }

        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        document.addEventListener('gesturechange', function(e) {
            e.preventDefault();
        });

        document.addEventListener('gestureend', function(e) {
            e.preventDefault();
        });
    </script>
</body>
</html>
