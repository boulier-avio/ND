<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>BOULIER gisement ADF sur ND</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background: white;
        }
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 24px;
            margin: 5px;
            touch-action: manipulation;
        }
        .cap-display {
            color: black;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 10px;
        }
        .desktop-controls {
            position: fixed;
            bottom: 80px;
            left: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .reponse-btn {
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            margin: 5px;
            font-size: 14px;
            cursor: pointer;
            width: 180px;
            text-align: center;
        }
        .contact-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 12px;
            color: #666;
            z-index: 100;
            background: rgba(255,255,255,0.9);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .contact-info a {
            color: #0066cc;
            text-decoration: none;
        }
        .contact-info a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="mobile-controls">
        <div class="cap-display">CAP: <span id="capValue">0</span>°</div>
        <button class="control-btn" id="capPlus">+</button>
        <button class="control-btn" id="capMoins">-</button>
        <button class="reponse-btn" id="toggleReponse">Afficher/Cacher Réponses</button>
    </div>

    <div class="desktop-controls">
        <button class="reponse-btn" id="desktopToggleReponse">Afficher/Cacher Réponses</button>
    </div>

    <div class="contact-info">
        <a href="mailto:renaud.boulier@ac-clermont.fr">contact: renaud.boulier@ac-clermont.fr</a>
    </div>

    <script>
        let imgNDcadre, imgNDmaquette, imgNDrose;
        let flecheNDDouble, flecheNDSimple, imgNDB, imgPlane;
        let rose = 0;
        let QDR1, QDR3, QDM, QDM1, GT, GT1;
        let mx1, mx2, my1, my2, mmx, mmy;
        let rot;
        let reponse = false;
        let baliseLH, baliseRH, avion, avion1;
        let isMobile = false;
        let imagesLoaded = false;
        
        // Variables pour le contrôle continu du cap
        let rightMousePressed = false;
        let leftMousePressed = false;
        let lastUpdateTime = 0;
        const CAP_CHANGE_INTERVAL = 16;

        // Variables pour le contrôle mobile
        let capPlusPressed = false;
        let capMoinsPressed = false;

        // Variables pour le zoom et déplacement
        let zoomScale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastTouchX, lastTouchY;
        let lastTouchDistance = 0;

        // Variable pour contrôler le déplacement de l'avion
        let aircraftMoving = false;

        // Variables pour la zone de délimitation des balises
        let baliseZone = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            padding: 50 // Marge autour des balises
        };

        function preload() {
            // Chargement des images avec chemins relatifs
            imgNDcadre = loadImage('NDcadre.png');
            imgNDmaquette = loadImage('NDmaquette.png');
            imgNDrose = loadImage('NDrose.png');
            flecheNDDouble = loadImage('NDDouble.png');
            flecheNDSimple = loadImage('NDSimple.png');
            imgNDB = loadImage('NDB.png');
            imgPlane = loadImage('plane.png');
            
            imagesLoaded = true;
            console.log('Toutes les images sont en cours de chargement');
        }

        function setup() {
            // Détection mobile
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      ('ontouchstart' in window) || 
                      (navigator.maxTouchPoints > 0);
            
            console.log('Is Mobile:', isMobile);
            
            let canvas = createCanvas(windowWidth, windowHeight);
            canvas.style('display', 'block');
            
            // Position initiale de l'avion au centre de la zone des balises
            mmx = width / 2;
            mmy = height / 2;
            baliseLH = createVector(0, -10);
            baliseRH = createVector(0, -10);
            imageMode(CENTER);
            rectMode(CENTER);
            textAlign(LEFT, CENTER);
            
            setupControls();
        }

        function setupControls() {
            // Configuration mobile
            if (isMobile) {
                document.getElementById('capPlus').addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    capPlusPressed = true;
                }, {passive: false});
                
                document.getElementById('capPlus').addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    capPlusPressed = false;
                }, {passive: false});
                
                document.getElementById('capMoins').addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    capMoinsPressed = true;
                }, {passive: false});
                
                document.getElementById('capMoins').addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    capMoinsPressed = false;
                }, {passive: false});
                
                document.getElementById('toggleReponse').addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    reponse = !reponse;
                });
                
                document.querySelector('.mobile-controls').style.display = 'flex';
                document.querySelector('.desktop-controls').style.display = 'none';
                document.querySelector('.contact-info').style.display = 'none'; // Cacher le contact sur mobile
            } else {
                // Configuration desktop
                document.getElementById('desktopToggleReponse').addEventListener('click', function(e) {
                    reponse = !reponse;
                });
                
                document.querySelector('.mobile-controls').style.display = 'none';
                document.querySelector('.desktop-controls').style.display = 'flex';
                document.querySelector('.contact-info').style.display = 'block';
            }
        }

        function draw() {
            background(255);
            
            // Mise à jour de l'affichage du cap
            document.getElementById('capValue').textContent = round(rose);

            // Mise à jour continue du cap
            updateCapContinuous();

            // Mise à jour de la position de l'avion sur desktop avec clic gauche
            if (!isMobile && leftMousePressed) {
                updateAircraftPosition();
            }

            // Appliquer la transformation de zoom et déplacement
            push();
            translate(offsetX, offsetY);
            scale(zoomScale);

            // Positions adaptatives
            let NDX, NDY, NDBX1, NDBY1, NDBX2, NDBY2;
            
            if (isMobile) {
                // Adaptation pour mode paysage
                if (windowWidth > windowHeight) {
                    // Mode paysage - layout horizontal
                    NDX = width * 0.25;
                    NDY = height * 0.3;
                    NDBX1 = width * 0.65;
                    NDBY1 = height * 0.25;
                    NDBX2 = width * 0.65;
                    NDBY2 = height * 0.5;
                } else {
                    // Mode portrait - layout vertical
                    NDX = width * 0.3;
                    NDY = height * 0.25;
                    NDBX1 = width * 0.7;
                    NDBY1 = height * 0.25;
                    NDBX2 = width * 0.7;
                    NDBY2 = height * 0.5;
                }
            } else {
                // Desktop - positions fixes
                NDX = 183;
                NDY = 183;
                NDBX1 = 553;
                NDBY1 = 183;
                NDBX2 = 753;
                NDBY2 = 383;
            }

            // Calculer et dessiner la zone de délimitation des balises
            calculateBaliseZone(NDBX1, NDBY1, NDBX2, NDBY2);
            drawBaliseZone();

            // Tailles adaptatives
            let cadreSize, roseSize, flecheLength;
            
            if (isMobile) {
                if (windowWidth > windowHeight) {
                    // Mode paysage - tailles réduites
                    cadreSize = min(width, height) * 0.3;
                    roseSize = min(width, height) * 0.22;
                    flecheLength = roseSize * 0.85;
                } else {
                    // Mode portrait
                    cadreSize = min(width, height) * 0.35;
                    roseSize = min(width, height) * 0.25;
                    flecheLength = roseSize * 0.85;
                }
            } else {
                // Desktop - tailles fixes
                cadreSize = 368;
                roseSize = 271;
                flecheLength = 231;
            }

            // Affichage des éléments principaux
            drawMainElements(NDX, NDY, cadreSize, roseSize, flecheLength, NDBX1, NDBY1, NDBX2, NDBY2);

            // Calculs de navigation
            calculateNavigation(NDX, NDY, NDBX1, NDBY1, NDBX2, NDBY2);

            // Affichage de l'avion
            drawAircraft(NDX);

            // Interface utilisateur
            drawInterface();

            pop(); // Fin de la transformation
        }

        function calculateBaliseZone(NDBX1, NDBY1, NDBX2, NDBY2) {
            // Calculer les limites de la zone autour des balises
            const minX = min(NDBX1, NDBX2) - baliseZone.padding;
            const maxX = max(NDBX1, NDBX2) + baliseZone.padding;
            const minY = min(NDBY1, NDBY2) - baliseZone.padding;
            const maxY = max(NDBY1, NDBY2) + baliseZone.padding;
            
            baliseZone.x = minX;
            baliseZone.y = minY;
            baliseZone.width = maxX - minX;
            baliseZone.height = maxY - minY;
        }

        function drawBaliseZone() {
            // Dessiner le carré de délimitation autour des balises
            stroke(0, 100, 255); // Bleu
            strokeWeight(2);
            noFill();
            rect(baliseZone.x + baliseZone.width/2, baliseZone.y + baliseZone.height/2, 
                 baliseZone.width, baliseZone.height);
            noStroke();
            
            // Ajouter un texte explicatif
            fill(0, 100, 255);
            textSize(12);
            textAlign(CENTER);
            text("Zone de déplacement de l'avion", 
                 baliseZone.x + baliseZone.width/2, 
                 baliseZone.y - 10);
            textAlign(LEFT);
        }

        function isInBaliseZone(x, y) {
            // Vérifier si les coordonnées sont dans la zone des balises
            return x >= baliseZone.x && 
                   x <= baliseZone.x + baliseZone.width && 
                   y >= baliseZone.y && 
                   y <= baliseZone.y + baliseZone.height;
        }

        function constrainToBaliseZone(x, y) {
            // Contraindre les coordonnées à la zone des balises
            let constrainedX = constrain(x, baliseZone.x, baliseZone.x + baliseZone.width);
            let constrainedY = constrain(y, baliseZone.y, baliseZone.y + baliseZone.height);
            return {x: constrainedX, y: constrainedY};
        }

        function updateCapContinuous() {
            let currentTime = millis();
            if (currentTime - lastUpdateTime > CAP_CHANGE_INTERVAL) {
                if (!isMobile && rightMousePressed) {
                    rose = (rose + 1) % 360;
                }
                if (isMobile) {
                    if (capPlusPressed) rose = (rose + 2) % 360;
                    if (capMoinsPressed) rose = (rose - 2 + 360) % 360;
                }
                lastUpdateTime = currentTime;
            }
        }

        function updateAircraftPosition() {
            // Sur desktop, l'avion suit la souris seulement si le clic gauche est maintenu
            // et seulement dans la zone des balises
            if (!isMobile && leftMousePressed) {
                let targetX = mouseX;
                let targetY = mouseY;
                
                // Ajuster les coordonnées pour le zoom
                let adjustedTargetX = (targetX - offsetX) / zoomScale;
                let adjustedTargetY = (targetY - offsetY) / zoomScale;
                
                // Vérifier si la position cible est dans la zone des balises
                if (isInBaliseZone(adjustedTargetX, adjustedTargetY)) {
                    mmx = targetX;
                    mmy = targetY;
                } else {
                    // Si en dehors, contraindre à la zone
                    let constrained = constrainToBaliseZone(adjustedTargetX, adjustedTargetY);
                    // Convertir retour aux coordonnées écran
                    mmx = constrained.x * zoomScale + offsetX;
                    mmy = constrained.y * zoomScale + offsetY;
                }
            }
        }

        function drawMainElements(NDX, NDY, cadreSize, roseSize, flecheLength, NDBX1, NDBY1, NDBX2, NDBY2) {
            if (imagesLoaded) {
                try {
                    // Cadre principal
                    image(imgNDcadre, NDX, NDY, cadreSize, cadreSize);
                    image(imgNDmaquette, NDX, NDY, cadreSize/10, cadreSize/10);

                    // Rose rotative
                    push();
                    translate(NDX, NDY);
                    rotate(radians(-rose));
                    image(imgNDrose, 0, 0, roseSize, roseSize); 
                    pop();
                    
                    // Flèches
                    push();
                    translate(NDX, NDY);
                    rotate(radians(QDM));  
                    image(flecheNDDouble, 0, 0, cadreSize, cadreSize);
                    pop();

                    push();
                    translate(NDX, NDY);
                    rotate(radians(QDM1));  
                    image(flecheNDSimple, 0, 0, cadreSize, cadreSize);
                    pop();

                    // Balises
                    image(imgNDB, NDBX1, NDBY1);
                    image(imgNDB, NDBX2, NDBY2);
                    
                    console.log('Images affichées avec succès');
                } catch (e) {
                    console.error('Erreur lors de l\'affichage des images:', e);
                    drawFallbackGraphics(NDX, NDY, cadreSize, roseSize, NDBX1, NDBY1, NDBX2, NDBY2);
                }
            } else {
                console.log('Images non chargées, utilisation du fallback');
                drawFallbackGraphics(NDX, NDY, cadreSize, roseSize, NDBX1, NDBY1, NDBX2, NDBY2);
            }

            // Trait jaune avec taille adaptative
            stroke(233, 255, 3);
            strokeWeight(2);
            let roseRadius = roseSize / 2;
            let markerLength = isMobile ? roseSize * 0.08 : 20;
            line(NDX, NDY - roseRadius + markerLength/2, NDX, NDY - roseRadius + markerLength); 
            noStroke();
        }

        function drawFallbackGraphics(NDX, NDY, cadreSize, roseSize, NDBX1, NDBY1, NDBX2, NDBY2) {
            // Cadre
            stroke(0);
            strokeWeight(2);
            noFill();
            rect(NDX, NDY, cadreSize, cadreSize);
            
            // Rose
            stroke(100);
            strokeWeight(1);
            noFill();
            circle(NDX, NDY, roseSize);
            
            // Avion maquette
            fill(100);
            noStroke();
            rect(NDX-15, NDY, 30, 10);
            
            // Balises
            fill(255, 0, 0);
            circle(NDBX1, NDBY1, 20);
            circle(NDBX2, NDBY2, 20);
            
            // Flèches
            stroke(255, 0, 0);
            strokeWeight(3);
            push();
            translate(NDX, NDY);
            rotate(radians(QDM));
            line(0, 0, 0, -100);
            pop();
            
            stroke(0, 0, 255);
            push();
            translate(NDX, NDY);
            rotate(radians(QDM1));
            line(0, 0, 0, -120);
            pop();
        }

        function calculateNavigation(NDX, NDY, NDBX1, NDBY1, NDBX2, NDBY2) {
            // Ajuster les coordonnées pour le zoom
            let adjustedMmx = (mmx - offsetX) / zoomScale;
            let adjustedMmy = (mmy - offsetY) / zoomScale;

            mx1 = adjustedMmx - NDBX1;
            my1 = adjustedMmy - NDBY1;
            avion = createVector(mx1, my1);
            
            let angle1 = atan2(my1, mx1);
            QDR1 = degrees(angle1);
            if (QDR1 < 0) QDR1 += 360;
            
            QDM1 = (QDR1 + 180) % 360;
            GT = (QDM1 - rose + 360) % 360;

            mx2 = adjustedMmx - NDBX2;
            my2 = adjustedMmy - NDBY2;
            avion1 = createVector(mx2, my2);
            
            let angle2 = atan2(my2, mx2);
            QDR3 = degrees(angle2);
            if (QDR3 < 0) QDR3 += 360;
            
            QDM = (QDR3 + 180) % 360;
            GT1 = (QDM - rose + 360) % 360;
        }

        function drawAircraft(NDX) {
            // Ajuster les coordonnées pour le zoom
            let adjustedMmx = (mmx - offsetX) / zoomScale;
            let adjustedMmy = (mmy - offsetY) / zoomScale;

            // Sur desktop, afficher l'avion seulement si le clic gauche est maintenu
            // Sur mobile, afficher l'avion seulement si on touche l'écran (sauf les boutons)
            const shouldShowAircraft = (!isMobile && leftMousePressed) || (isMobile && aircraftMoving);
            
            if (shouldShowAircraft) {
                if (!isMobile) noCursor();
                push();
                translate(adjustedMmx, adjustedMmy);
                rotate(radians(rose));
                if (imagesLoaded) {
                    try {
                        image(imgPlane, 1, 5);
                    } catch (e) {
                        // Fallback pour l'avion
                        drawFallbackAircraft();
                    }
                } else {
                    // Fallback pour l'avion
                    drawFallbackAircraft();
                }
                pop();
            } else {
                if (!isMobile) cursor(ARROW);
            }
        }

        function drawFallbackAircraft() {
            fill(255, 0, 0);
            triangle(-15, -10, 15, -10, 0, -25);
            rect(-5, 0, 10, 15);
        }

        function drawInterface() {
            let infoX = isMobile ? 10 : 5;
            let infoY = isMobile ? height * 0.65 : 400;
            let textStep = 15;

            fill(0);
            textSize(isMobile ? 11 : 12);
            
            // Labels toujours visibles
            text("QDR1 =", infoX + 5, infoY);
            text("QDM1 =", infoX + 5, infoY + textStep);
            text("GT1  =", infoX + 5, infoY + textStep * 2);
            text("CAP  =", infoX + 5, infoY + textStep * 3);
            text("QDR2 =", infoX + 5, infoY + textStep * 4);
            text("QDM2 =", infoX + 5, infoY + textStep * 5);
            text("GT2  =", infoX + 5, infoY + textStep * 6);

            // Valeurs cachées ou affichées selon l'état
            if (reponse) {
                text(round(QDR1), infoX + 55, infoY);
                text(round(QDM1), infoX + 55, infoY + textStep);
                text(round(GT), infoX + 55, infoY + textStep * 2);
                text(round(rose), infoX + 55, infoY + textStep * 3);
                text(round(QDR3), infoX + 55, infoY + textStep * 4);
                text(round(QDM), infoX + 55, infoY + textStep * 5);
                text(round(GT1), infoX + 55, infoY + textStep * 6);
            } else {
                // Tout caché
                text("---", infoX + 55, infoY);
                text("---", infoX + 55, infoY + textStep);
                text("---", infoX + 55, infoY + textStep * 2);
                text("---", infoX + 55, infoY + textStep * 3);
                text("---", infoX + 55, infoY + textStep * 4);
                text("---", infoX + 55, infoY + textStep * 5);
                text("---", infoX + 55, infoY + textStep * 6);
            }

            // Instructions mobiles
            if (isMobile) {
                fill(0);
                textSize(12);
                textAlign(CENTER);
                text("Touchez l'écran pour déplacer l'avion", width/2, 50);
                text("Pincez pour zoomer", width/2, 70);
                text("Déplacement uniquement dans la zone bleue", width/2, 90);
                textAlign(LEFT);
            }

            // Aide desktop
            if (!isMobile) {
                fill(0);
                textSize(12);
                text("Clic gauche maintenu: déplacer avion (zone bleue uniquement)", infoX, infoY + textStep * 8);
                text("Clic droit maintenu: changer cap", infoX, infoY + textStep * 9);
                text("Touche 1 ou bouton: afficher/cacher valeurs", infoX, infoY + textStep * 10);
            }
        }

        function mousePressed() {
            if (!isMobile) {
                if (mouseButton === RIGHT) {
                    rightMousePressed = true;
                    lastUpdateTime = millis();
                    return false;
                } else if (mouseButton === LEFT) {
                    leftMousePressed = true;
                    return false;
                }
            }
            return false;
        }

        function mouseReleased() {
            if (!isMobile) {
                if (mouseButton === RIGHT) {
                    rightMousePressed = false;
                    return false;
                } else if (mouseButton === LEFT) {
                    leftMousePressed = false;
                    return false;
                }
            }
            return false;
        }

        function keyPressed() {
            if (key === '1') {
                reponse = !reponse;
            }
        }

        function touchStarted(event) {
            if (isMobile) {
                // Vérifier si le toucher est sur un bouton
                const touchX = event.touches[0].clientX;
                const touchY = event.touches[0].clientY;
                
                // Obtenir les éléments de contrôle
                const capPlusBtn = document.getElementById('capPlus');
                const capMoinsBtn = document.getElementById('capMoins');
                const reponseBtn = document.getElementById('toggleReponse');
                
                // Vérifier si le toucher est sur un bouton
                const isOnButton = 
                    isTouchInElement(touchX, touchY, capPlusBtn) ||
                    isTouchInElement(touchX, touchY, capMoinsBtn) ||
                    isTouchInElement(touchX, touchY, reponseBtn);
                
                // Si le toucher n'est pas sur un bouton, déplacer l'avion
                if (!isOnButton) {
                    // Ajuster les coordonnées pour le zoom
                    let adjustedTouchX = (touchX - offsetX) / zoomScale;
                    let adjustedTouchY = (touchY - offsetY) / zoomScale;
                    
                    // Vérifier si le toucher est dans la zone des balises
                    if (isInBaliseZone(adjustedTouchX, adjustedTouchY)) {
                        aircraftMoving = true;
                        mmx = touchX;
                        mmy = touchY;
                        
                        if (touches.length === 1) {
                            // Déplacement de l'avion avec un seul doigt
                            isDragging = true;
                            lastTouchX = touchX;
                            lastTouchY = touchY;
                        } else if (touches.length === 2) {
                            // Zoom avec deux doigts
                            lastTouchDistance = dist(
                                touches[0].x, touches[0].y,
                                touches[1].x, touches[1].y
                            );
                        }
                    }
                }
            }
            return false;
        }

        function touchMoved(event) {
            if (isMobile && aircraftMoving) {
                if (touches.length === 1 && isDragging) {
                    // Déplacement de l'avion avec contrainte à la zone
                    let targetX = touches[0].x;
                    let targetY = touches[0].y;
                    
                    // Ajuster les coordonnées pour le zoom
                    let adjustedTargetX = (targetX - offsetX) / zoomScale;
                    let adjustedTargetY = (targetY - offsetY) / zoomScale;
                    
                    // Vérifier si la position cible est dans la zone des balises
                    if (isInBaliseZone(adjustedTargetX, adjustedTargetY)) {
                        mmx = targetX;
                        mmy = targetY;
                    } else {
                        // Si en dehors, contraindre à la zone
                        let constrained = constrainToBaliseZone(adjustedTargetX, adjustedTargetY);
                        // Convertir retour aux coordonnées écran
                        mmx = constrained.x * zoomScale + offsetX;
                        mmy = constrained.y * zoomScale + offsetY;
                    }
                } else if (touches.length === 2) {
                    // Zoom
                    let currentDistance = dist(
                        touches[0].x, touches[0].y,
                        touches[1].x, touches[1].y
                    );
                    
                    let zoomFactor = currentDistance / lastTouchDistance;
                    zoomScale *= zoomFactor;
                    zoomScale = constrain(zoomScale, 0.5, 3.0);
                    
                    lastTouchDistance = currentDistance;
                }
            }
            return false;
        }

        function touchEnded() {
            if (isMobile) {
                aircraftMoving = false;
                if (touches.length === 0) {
                    isDragging = false;
                }
            }
            return false;
        }

        // Fonction utilitaire pour vérifier si un toucher est dans un élément
        function isTouchInElement(touchX, touchY, element) {
            const rect = element.getBoundingClientRect();
            return (
                touchX >= rect.left &&
                touchX <= rect.right &&
                touchY >= rect.top &&
                touchY <= rect.bottom
            );
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }

        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        document.addEventListener('gesturechange', function(e) {
            e.preventDefault();
        });

        document.addEventListener('gestureend', function(e) {
            e.preventDefault();
        });
    </script>
</body>
</html>
